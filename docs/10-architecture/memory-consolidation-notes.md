# 메모리 세대 전환 이후 의미론적 병합 전략 제안

## 배경 요약
- `GraphStore.upsertQuery`는 정규화된 canonical key 혹은 코사인 유사도가 `tauDup` 이상일 때만 반복 가중치를 올려 동일 노드로 취급하고, 그 외에는 새로운 질의 노드를 추가합니다.【F:packages/core/src/memory/graph-store.ts†L123-L158】
- 노드 승격과 입양은 세대(`young`/`old`) 메타데이터와 가중치만 재조정하며, 실제 텍스트 병합이나 그래프 재구성은 수행하지 않습니다.【F:packages/core/src/memory/graph-store.ts†L211-L279】
- 세션 종료 시 오케스트레이터는 상위 질의 노드를 세션 스토어에서 분리한 뒤 에이전트 스토어로 입양하며 세대만 `old`로 승격합니다.【F:packages/core/src/memory/memory-orchestrator.ts†L107-L181】

이로 인해 동일/유사 질의가 장기간 축적되어도 실제 텍스트 통합이나 의미론적 정리는 이루어지지 않습니다.

## 문제 정의
1. **LLM 비용 부담**: 모든 유사 노드를 LLM으로 병합하면 비용이 급증합니다.
2. **맥락 과다/부족 문제**: LLM에 제공할 컨텍스트가 많으면 초점이 흐려지고, 적으면 중요 정보가 누락될 수 있습니다.
3. **그래프 일관성**: 병합으로 새 노드를 만들면 기존 엣지·가중치를 어떻게 재배치할지 정의가 필요합니다.
4. **의미 있는 기억 심볼 부재**: 스몰토크와 같은 단기 대화가 장기 지식과 분리되지 않아, 에이전트별 핵심 태그가 존재하지 않습니다.

## 구현 현황 (태그 중심 정리의 1차 단계)
- `GraphStore`가 태그용 canonical key를 생성하고 `upsertTag`, `linkTagToQuery`, `getEdges` API를 제공해 세션·에이전트 그래프 모두에서 `entity` 노드를 경량으로 관리할 수 있습니다.【F:packages/core/src/memory/graph-store.ts†L158-L198】【F:packages/core/src/memory/graph-store.ts†L339-L397】
- `LlmTagExtractor`는 LLM 브릿지를 통해 대화 묶음과 기존 태그 목록을 함께 전달하고, JSON 배열 태그 응답을 파싱해 canonical key 기준으로 중복을 제거합니다.【F:packages/core/src/memory/tag-extractor.ts†L1-L92】
- `MemoryOrchestrator`는 세션별 태깅 버퍼를 유지하고, 구성에서 `tagging.window`/`maxTagsPerBatch`를 설정하면 최근 질의 묶음마다 비동기 LLM 태깅 작업을 큐잉합니다. 승격이나 세션 종료 전 `waitForTagging`/`finalizeSession`이 큐를 비워 관련 태그를 세션 그래프에 연결하고, 이후 에이전트 그래프로 병합합니다.【F:packages/core/src/memory/memory-orchestrator.ts†L15-L329】
- 통합된 흐름은 `tag batching links queries and promotes tags with hotspots` 테스트로 검증되며, 태그 생성·세션 링크·승격 이후 에이전트 그래프에서 태그-질의 엣지가 유지되는지 확인합니다.【F:packages/core/src/memory/__tests__/orchestrator.test.ts†L77-L107】

## 제안 전략
### 1. 다단계 후보 선별 파이프라인
1. **경량 필터**: 임베딩 코사인 유사도, canonical key 매칭, `generationUpdatedAt` 역순 정렬 등으로 상위 후보군을 만든 뒤, 반복/피드백 가중치가 낮은 `young` 노드만 대상으로 삼습니다.【F:packages/core/src/memory/graph-store.ts†L139-L173】【F:packages/core/src/memory/graph-store.ts†L333-L376】
2. **가벼운 압축 단계**: 선택된 후보 텍스트를 512~768토큰 이하로 잘라 rule-based 요약(예: 중요 문장 추출) 후 LLM에 전달해 비용을 줄입니다.
3. **LLM 호출**: 특정 임계치(예: 후보 묶음 내 평균 유사도 > 0.8, 가중치 합이 일정 값 이상)일 때만 LLM을 호출해 대표 질의와 키포인트를 생성합니다.

### 2. 컨텍스트 예산 관리
- **토큰 버짓 동적 설정**: LLM 입력 토큰 한도를 전체 예산의 일정 비율(예: 일일 30%)로 제한하고, 남은 예산이 부족하면 병합 작업을 건너뜁니다.
- **요약 깊이 조절**: 후보가 많을수록 우선순위를 낮춰 `old` 세대만 요약하거나, 최신 `young` 노드 중 중요도 상위 K개만 포함합니다.

### 3. 그래프 재구성 가이드라인
- **대표 노드 생성**: LLM이 제안한 통합 텍스트로 새 `summary` 타입 노드를 만들고, 병합 대상 질의는 이 노드에 `consolidated_into` 엣지를 연결합니다.
- **가중치/세대 갱신**: 새 노드는 기본적으로 `old` 세대에 두되, 기존 노드의 `repeat`/`feedback`을 합산하여 초기 가중치로 설정하고, 원본 노드는 `archived` 같은 보조 세대로 강등하거나 LRU 대상에 넣습니다.
- **히스토리 추적**: 병합 전/후 스냅샷을 로그로 남겨 회귀 및 디버깅이 가능하도록 합니다.

### 4. 태그(의미 심볼) 중심 기억 정리
1. **대화 묶음 추출**: 세션 그래프에 최근 5개 내외의 턴을 버퍼링했다가, 배치 시점마다 묶음으로 태그 추출 워커에 전달합니다. 세대 정보와 반복 가중치를 함께 넘겨 중요도가 낮은 스몰토크 묶음은 필터링합니다.
2. **키워드 정규화**: 워커는 기존 `entity` 노드 목록을 함께 받아, LLM이 반환한 키워드가 이미 존재하면 동일 canonical key로 재사용합니다. 유사도 임계치 이내면 기존 태그에 반복 가중치만 추가하고, 새 태그는 `entity` 노드로 생성합니다.
3. **지식 매핑**: 태그가 1개 이상 생성되면, 해당 태그와 연결된 질의·요약 노드를 스캔해 중요 지식을 `old` 세대로 승격하거나 대표 요약 노드를 생성합니다. 태그에 매핑된 노드는 스몰토크보다 높은 우선순위를 받아 장기 메모리에 남습니다.
4. **태그 유지 전략**: 세션 종료 시 `promoteHotspotsFromSession`이 태그와 질의를 함께 입양하도록 확장하거나, 태그만 에이전트 스토어에 보존하고 세션 그래프에서 참조를 끊어 메모리 사용량을 제어합니다.

### 5. 배치 스케줄링
- **수면 주기 트리거**: 세션 종료 또는 일정 시간(예: 1시간)마다 배치 작업을 예약하고, 한 번에 처리할 노드 수를 제한합니다.
- **온디바이스 LLM 캐싱**: 동일한 질의 묶음에 대해 재요약이 반복되지 않도록 입력 해시를 기반으로 결과를 캐싱합니다.

## 향후 구현 고려사항
1. `GraphStore`에 병합 대상 노드를 묶어 반환하는 `collectMergeCandidates`(세대·유사도·가중치 기반) API 추가.
2. `MemoryOrchestrator`에 비동기 병합 워커를 붙여 LLM 호출 및 그래프 업데이트를 순차적으로 처리.
3. 테스트 확장: 병합 후 검색 품질, 요약 노드 생성, 원본 노드 보존/제거 시나리오 검증.
4. 모니터링: 병합 빈도, LLM 호출 비용, 검색 hit rate 변화를 추적해 파라미터를 조정.

위 접근은 LLM 호출을 최소화하면서도 세대 기반 인덱싱 구조를 활용해 의미론적 병합을 점진적으로 도입할 수 있는 로드맵을 제공합니다.
