/*
  RPC Codegen (Phase A+, JS version)
  - Scans contracts (*.contract.ts)
  - Writes (with safe overwrite):
    * shared/rpc/gen/channels.ts (channel constants)
    * renderer/rpc/gen/<ns>.client.ts (typed client via z.input/z.output)
    * main/<ns>/gen/<ns>.controller.ts (Nest controller stubs with ZodValidationPipe)
*/
import fs from 'node:fs';
import path from 'node:path';

const HEADER = '// AUTO-GENERATED FILE. DO NOT EDIT.';

function findContractFiles(root) {
  const files = [];
  for (const entry of fs.readdirSync(root, { withFileTypes: true })) {
    const p = path.join(root, entry.name);
    if (entry.isDirectory()) files.push(...findContractFiles(p));
    else if (entry.isFile() && entry.name.endsWith('.contract.ts')) files.push(p);
  }
  return files.sort();
}

function extractSpec(filePath) {
  const text = fs.readFileSync(filePath, 'utf8');
  const nsMatch = text.match(/namespace:\s*'([^']+)'/);
  const namespace = nsMatch ? nsMatch[1] : path.basename(filePath).replace(/\.contract\.ts$/, '');
  // naive method parser: name and channel
  const blockRegex = /(\w+)\s*:\s*{([\s\S]*?)}/g;
  const methods = {};
  let m;
  while ((m = blockRegex.exec(text))) {
    const name = m[1];
    const block = m[2];
    const ch = /channel:\s*'([^']+)'/.exec(block);
    if (!ch) continue;
    const hasPayload = /payload\s*:/.test(block);
    const hasResponse = /response\s*:/.test(block);
    methods[name] = { channel: ch[1], hasPayload, hasResponse };
  }
  return { namespace, methods };
}

function writeFileGenerated(file, content) {
  fs.mkdirSync(path.dirname(file), { recursive: true });
  if (fs.existsSync(file)) {
    const prev = fs.readFileSync(file, 'utf8');
    const hasHeader = prev.startsWith(HEADER);
    if (!hasHeader) {
      const alt = file.replace(/\.ts$/, '.gen.new.ts');
      fs.writeFileSync(alt, content, 'utf8');
      console.warn(`[rpc-codegen] Skip overwrite (no header). Wrote candidate: ${alt}`);
      return;
    }
    if (prev === content) {
      return; // no changes
    }
  }
  fs.writeFileSync(file, content, 'utf8');
}

function writeChannelsFile(specs, outFile) {
  const lines = [];
  lines.push(HEADER);
  lines.push('// Generated by scripts/rpc-codegen.js');
  lines.push('');
  lines.push('export const Channels = {');
  for (const spec of specs) {
    lines.push(`  ${spec.namespace}: {`);
    for (const [name, info] of Object.entries(spec.methods)) {
      lines.push(`    ${name}: '${info.channel}',`);
    }
    lines.push('  },');
  }
  lines.push('} as const;');
  lines.push('');
  const flat = [];
  for (const spec of specs) {
    for (const [name, info] of Object.entries(spec.methods)) {
      const constName = `${spec.namespace}_${name}`.replace(/[^a-zA-Z0-9_]/g, '_');
      flat.push(`export const ${constName} = '${info.channel}' as const;`);
    }
  }
  lines.push(...flat);
  writeFileGenerated(outFile, lines.join('\n') + '\n');
}

function writeRendererClient(spec, outDir) {
  const className = `${capitalize(spec.namespace)}Client`;
  const contractConst = `${capitalize(spec.namespace)}Contract`;
  const contractImportPath = `../../../shared/rpc/contracts/${spec.namespace}.contract`;
  const lines = [];
  lines.push(HEADER);
  lines.push(`import type { RpcClient } from '../../../shared/rpc/transport';`);
  lines.push(`import type { z } from 'zod';`);
  lines.push(`import { ${contractConst} as C } from '${contractImportPath}';`);
  lines.push('');
  lines.push(`export class ${className} {`);
  lines.push(`  constructor(private readonly transport: RpcClient) {}`);
  for (const [name, info] of Object.entries(spec.methods)) {
    const payloadType = info.hasPayload ? `z.input<typeof C.methods['${name}'].payload>` : 'void';
    const resultType = info.hasResponse ? `z.output<typeof C.methods['${name}'].response>` : 'void';
    lines.push('');
    if (info.hasPayload) {
      lines.push(`  ${name}(payload: ${payloadType}): Promise<${resultType}> {`);
      lines.push(`    return this.transport.request(C.methods['${name}'].channel, payload);`);
      lines.push('  }');
    } else {
      lines.push(`  ${name}(): Promise<${resultType}> {`);
      lines.push(`    return this.transport.request(C.methods['${name}'].channel);`);
      lines.push('  }');
    }
  }
  lines.push('}');
  const file = path.join(outDir, `${spec.namespace}.client.ts`);
  writeFileGenerated(file, lines.join('\n') + '\n');
}

function writeMainController(spec, outDir) {
  const className = `Generated${capitalize(spec.namespace)}Controller`;
  const contractConst = `${capitalize(spec.namespace)}Contract`;
  const contractImportPath = `../../../shared/rpc/contracts/${spec.namespace}.contract`;
  const lines = [];
  lines.push(HEADER);
  lines.push(`import { Controller } from '@nestjs/common';`);
  lines.push(`import { EventPattern, Payload } from '@nestjs/microservices';`);
  lines.push(`import type { z } from 'zod';`);
  lines.push(`import { ZodValidationPipe } from '../../common/zod-validation.pipe';`);
  lines.push(`import { ${contractConst} as C } from '${contractImportPath}';`);
  lines.push('');
  lines.push(`@Controller()`);
  lines.push(`export class ${className} {`);
  for (const [name, info] of Object.entries(spec.methods)) {
    lines.push('');
    lines.push(`  @EventPattern('${info.channel}')`);
    if (info.hasPayload) {
      lines.push(
        `  async ${name}(@Payload(new ZodValidationPipe(C.methods['${name}'].payload)) payload: z.input<typeof C.methods['${name}'].payload>) {`
      );
    } else {
      lines.push(`  async ${name}() {`);
    }
    if (info.hasResponse) {
      lines.push(`    // Expected return: z.output<typeof C.methods['${name}'].response>`);
    }
    lines.push(`    throw new Error('NotImplemented: wire ${spec.namespace}.${name}');`);
    lines.push('  }');
  }
  lines.push('}');
  const file = path.join(outDir, `${spec.namespace}.controller.ts`);
  writeFileGenerated(file, lines.join('\n') + '\n');
}

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function main() {
  const repoRoot = path.resolve(__dirname, '..');
  const contractsRoot = path.resolve(repoRoot, 'apps/gui/src/shared/rpc/contracts');
  const channelsOut = path.resolve(repoRoot, 'apps/gui/src/shared/rpc/gen/channels.ts');
  if (!fs.existsSync(contractsRoot)) {
    console.error('No contracts folder:', contractsRoot);
    process.exit(1);
  }
  const files = findContractFiles(contractsRoot);
  const specs = files.map(extractSpec);
  writeChannelsFile(specs, channelsOut);
  console.log(
    `[rpc-codegen] Wrote ${path.relative(repoRoot, channelsOut)} from ${files.length} contract(s).`
  );
  for (const spec of specs) {
    writeRendererClient(spec, path.resolve(repoRoot, 'apps/gui/src/renderer/rpc/gen'));
    writeMainController(spec, path.resolve(repoRoot, `apps/gui/src/main/${spec.namespace}/gen`));
  }
}

main();
