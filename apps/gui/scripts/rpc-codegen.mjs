/*
  RPC Codegen (GUI-local)
  - Scans contracts (*.contract.ts) under app root
  - Writes (with safe overwrite):
    * src/shared/rpc/gen/channels.ts (channel constants)
    * src/renderer/rpc/gen/<ns>.client.ts (typed client via z.input/z.output)
    * src/main/<ns>/gen/<ns>.controller.ts (Nest controller stubs with ZodValidationPipe)
    * src/shared/rpc/gen/<ns>.types.d.ts (declaration-only helper types)
*/
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const HEADER = '// AUTO-GENERATED FILE. DO NOT EDIT.';

function findContractFiles(root) {
  const files = [];
  for (const entry of fs.readdirSync(root, { withFileTypes: true })) {
    const p = path.join(root, entry.name);
    if (entry.isDirectory()) {
      files.push(...findContractFiles(p));
    } else if (entry.isFile() && entry.name.endsWith('.contract.ts')) {
      files.push(p);
    }
  }
  return files.sort();
}

function extractSpec(filePath) {
  const text = fs.readFileSync(filePath, 'utf8');
  const nsMatch = text.match(/namespace:\s*'([^']+)'/);
  const namespace = nsMatch ? nsMatch[1] : path.basename(filePath).replace(/\.contract\.ts$/, '');

  const methodsIdx = text.indexOf('methods');
  let inner = '';
  if (methodsIdx >= 0) {
    const braceStart = text.indexOf('{', methodsIdx);
    if (braceStart >= 0) {
      let depth = 0;
      for (let i = braceStart; i < text.length; i++) {
        const ch = text[i];
        if (ch === '{') {
          depth++;
        } else if (ch === '}') {
          depth--;
          if (depth === 0) {
            inner = text.slice(braceStart + 1, i);
            break;
          }
        }
      }
    }
  }

  const methods = {};
  let i = 0;
  while (i < inner.length) {
    while (i < inner.length && /[\s,]/.test(inner[i])) {
      i++;
    }
    if (i >= inner.length) {
      break;
    }
    let name = '';
    if (inner[i] === "'" || inner[i] === '"') {
      const quote = inner[i++];
      const start = i;
      while (i < inner.length && inner[i] !== quote) {
        i++;
      }
      name = inner.slice(start, i);
      i++;
    } else {
      const start = i;
      while (i < inner.length && /[A-Za-z0-9_-]/.test(inner[i])) {
        i++;
      }
      name = inner.slice(start, i);
    }
    while (i < inner.length && /\s/.test(inner[i])) {
      i++;
    }
    if (inner[i] !== ':') {
      i++;
      continue;
    }
    i++;
    while (i < inner.length && /\s/.test(inner[i])) {
      i++;
    }
    if (inner[i] !== '{') {
      continue;
    }
    const bodyStart = i;
    let depth = 0;
    while (i < inner.length) {
      const ch = inner[i++];
      if (ch === '{') {
        depth++;
      } else if (ch === '}') {
        depth--;
        if (depth === 0) {
          break;
        }
      }
    }
    const body = inner.slice(bodyStart + 1, i - 1);
    const chMatch = /channel:\s*'([^']+)'/.exec(body);
    if (!chMatch) {
      continue;
    }
    if (!name && chMatch[1].includes('.')) {
      name = chMatch[1].split('.').slice(1).join('.');
    }
    const hasPayload = /\bpayload\s*:/.test(body);
    const hasResponse = /\bresponse\s*:/.test(body);
    const hasStreamResponse = /\bstreamResponse\s*:/.test(body);
    methods[name] = { channel: chMatch[1], hasPayload, hasResponse, hasStreamResponse };
  }
  return { namespace, methods };
}

function writeFileGenerated(file, content) {
  fs.mkdirSync(path.dirname(file), { recursive: true });
  if (fs.existsSync(file)) {
    const prev = fs.readFileSync(file, 'utf8');
    const hasHeader = prev.startsWith(HEADER);
    if (!hasHeader) {
      const alt = file.replace(/\.ts$/, '.gen.new.ts');
      fs.writeFileSync(alt, content, 'utf8');
      console.warn(`[rpc-codegen] Skip overwrite (no header). Wrote candidate: ${alt}`);
      return;
    }
    if (prev === content) {
      return;
    }
  }
  fs.writeFileSync(file, content, 'utf8');
}

function safeName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, '_');
}
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function writeChannelsFile(specs, outFile) {
  const lines = [];
  lines.push(HEADER);
  lines.push('// Generated by apps/gui/scripts/rpc-codegen.mjs');
  lines.push('');
  lines.push('export const Channels = {');
  for (const spec of specs) {
    lines.push(`  ${spec.namespace}: {`);
    for (const [name, info] of Object.entries(spec.methods)) {
      const key = safeName(name);
      lines.push(`    ${key}: '${info.channel}',`);
    }
    lines.push('  },');
  }
  lines.push('} as const;');
  lines.push('');
  const flat = [];
  for (const spec of specs) {
    for (const [name, info] of Object.entries(spec.methods)) {
      const constName = `${spec.namespace}_${name}`.replace(/[^a-zA-Z0-9_]/g, '_');
      flat.push(`export const ${constName} = '${info.channel}' as const;`);
    }
  }
  lines.push(...flat);
  writeFileGenerated(outFile, lines.join('\n') + '\n');
}

function writeRendererClient(spec, outDir) {
  const className = `${capitalize(spec.namespace)}Client`;
  const contractConst = `${capitalize(spec.namespace)}Contract`;
  const contractImportPath = `../../../shared/rpc/contracts/${spec.namespace}.contract`;
  const lines = [];
  lines.push(HEADER);
  lines.push(`import type { RpcClient, CloseFn } from '../../../shared/rpc/transport';`);
  lines.push(`import { ${contractConst} as C } from '${contractImportPath}';`);
  lines.push(`import { z } from 'zod';`);
  lines.push('');
  lines.push(`export class ${className} {`);
  lines.push(`  constructor(private readonly transport: RpcClient) {}`);
  for (const [name, info] of Object.entries(spec.methods)) {
    const mname = safeName(name);
    const payloadType = info.hasPayload
      ? `z.input<typeof C.methods['${name}']['payload']>`
      : 'void';
    const resultType = info.hasResponse
      ? `z.output<typeof C.methods['${name}']['response']>`
      : 'void';
    const streamType = info.hasStreamResponse
      ? `z.output<typeof C.methods['${name}']['streamResponse']>`
      : 'void';
    lines.push('');
    if (info.hasStreamResponse) {
      if (info.hasPayload) {
        lines.push(
          `  ${mname}Stream(payload: ${payloadType}): AsyncGenerator<${streamType}, void, unknown> {`
        );
        lines.push(
          `    return this.transport.stream ? this.transport.stream<${streamType}>(C.methods['${name}'].channel, payload) : (async function*(){})()`
        );
        lines.push('  }');
      } else {
        lines.push(`  ${mname}Stream(): AsyncGenerator<${streamType}, void, unknown> {`);
        lines.push(
          `    return this.transport.stream ? this.transport.stream<${streamType}>(C.methods['${name}'].channel) : (async function*(){})()`
        );
        lines.push('  }');
      }
      lines.push(`  ${mname}On(handler: (ev: ${streamType}) => void): CloseFn {`);
      lines.push(
        `    return this.transport.on<${streamType}>(C.methods['${name}'].channel, handler);`
      );
      lines.push('  }');
      continue;
    }
    if (info.hasPayload) {
      lines.push(`  ${mname}(payload: ${payloadType}): Promise<${resultType}> {`);
      lines.push(`    return this.transport.request(C.methods['${name}'].channel, payload);`);
      lines.push('  }');
    } else {
      lines.push(`  ${mname}(): Promise<${resultType}> {`);
      lines.push(`    return this.transport.request(C.methods['${name}'].channel);`);
      lines.push('  }');
    }
  }
  lines.push('}');
  const file = path.join(outDir, `${spec.namespace}.client.ts`);
  writeFileGenerated(file, lines.join('\n') + '\n');
}

function writeSharedTypes(spec, outDir) {
  const contractPath = `../contracts/${spec.namespace}.contract`;
  const lines = [];
  lines.push(HEADER);
  lines.push('// Declaration-only types for generated RPC clients');
  lines.push('');
  for (const [name, info] of Object.entries(spec.methods)) {
    const mname = safeName(name);
    const base = `typeof import('${contractPath}').${capitalize(spec.namespace)}Contract['methods']['${name}']`;
    if (info.hasPayload) {
      lines.push(`export type ${mname}_Payload = import('zod').infer<${base}['payload']>;`);
    } else {
      lines.push(`export type ${mname}_Payload = void;`);
    }
    if (info.hasResponse) {
      lines.push(`export type ${mname}_Result = import('zod').infer<${base}['response']>;`);
    } else {
      lines.push(`export type ${mname}_Result = void;`);
    }
    if (info.hasStreamResponse) {
      lines.push(`export type ${mname}_Stream = import('zod').infer<${base}['streamResponse']>;`);
    }
    lines.push('');
  }
  const file = path.join(outDir, `${spec.namespace}.types.d.ts`);
  writeFileGenerated(file, lines.join('\n') + '\n');
}

function writeMainController(spec, outDir) {
  const className = `Generated${capitalize(spec.namespace)}Controller`;
  const contractConst = `${capitalize(spec.namespace)}Contract`;
  const contractImportPath = `../../../shared/rpc/contracts/${spec.namespace}.contract`;
  const lines = [];
  lines.push(HEADER);
  lines.push(`import { Controller } from '@nestjs/common';`);
  lines.push(`import { EventPattern, Payload } from '@nestjs/microservices';`);
  lines.push(`import { z } from 'zod';`);
  lines.push(`import { ZodValidationPipe } from '../../common/zod-validation.pipe';`);
  lines.push(`import { ${contractConst} as C } from '${contractImportPath}';`);
  lines.push('');
  lines.push(`@Controller()`);
  lines.push(`export class ${className} {`);
  for (const [name, info] of Object.entries(spec.methods)) {
    const mname = safeName(name);
    lines.push('');
    lines.push(`  @EventPattern('${info.channel}')`);
    const payloadType = info.hasPayload
      ? `z.input<typeof C.methods['${name}']['payload']>`
      : 'void';
    const returnType = info.hasResponse
      ? `z.output<typeof C.methods['${name}']['response']>`
      : 'void';
    if (info.hasPayload) {
      lines.push(
        `  async ${mname}(@Payload(new ZodValidationPipe(C.methods['${name}']['payload'])) payload: ${payloadType}): Promise<${returnType}> {`
      );
    } else {
      lines.push(`  async ${mname}(): Promise<${returnType}> {`);
    }
    if (info.hasResponse) {
      lines.push(`    // Expected return: z.output<typeof C.methods['${name}']['response']>`);
    }
    lines.push(`    throw new Error('NotImplemented: wire ${spec.namespace}.${name}');`);
    lines.push('  }');
  }
  lines.push('}');
  const file = path.join(outDir, `${spec.namespace}.controller.ts`);
  writeFileGenerated(file, lines.join('\n') + '\n');
}

function main() {
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const appRoot = path.resolve(__dirname, '..');
  const contractsRoot = path.resolve(appRoot, 'src/shared/rpc/contracts');
  const channelsOut = path.resolve(appRoot, 'src/shared/rpc/gen/channels.ts');
  if (!fs.existsSync(contractsRoot)) {
    console.error('No contracts folder:', contractsRoot);
    process.exit(1);
  }
  const files = findContractFiles(contractsRoot);
  const specs = files.map(extractSpec);
  writeChannelsFile(specs, channelsOut);
  console.log(
    `[rpc-codegen] Wrote ${path.relative(appRoot, channelsOut)} from ${files.length} contract(s).`
  );
  for (const spec of specs) {
    writeRendererClient(spec, path.resolve(appRoot, 'src/renderer/rpc/gen'));
    writeMainController(spec, path.resolve(appRoot, `src/main/${spec.namespace}/gen`));
    writeSharedTypes(spec, path.resolve(appRoot, 'src/shared/rpc/gen'));
  }
}

main();
